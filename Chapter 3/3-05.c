/* Exercise 3-5. Write the function itob(n,s,b) that converts the
 * integer n into a base b character representation in the string s.
 * In particular, itob(n,s,16) formats n as a hexadecimal integer in
 * s.
 */

/* General Idea.

   This is somewhat similar to the itoa function. In itoa function,
   the digits are generated by getting the remainder of the division
   of n and 10. In the case of itoa, b = 10. Using this idea, we can
   get the digits of any number n, by dividing n by b, and getting
   the remainder. The remainder is our digit for that particular base
   b. We also add a special case if b = 16. Since the remainder can
   have the values 10 - 15, we change them into the following:

   		if remainder = 10, save 'a' to s.
		if remainder = 11, save 'b' to s.
		if remainder = 12, save 'c' to s.
		if remainder = 13, save 'd' to s.
		if remainder = 14, save 'e' to s.
		if remainder = 15, save 'f' to s.

  Also, we only consider the sign if base is equal to 10. Similar to
  the itoa function.

Algorithm:

	I1. [Get the sign] sign <- n;
	I2. [Is sign negative?] If sign < 0 and b = 10, Set n <- -n;
	I3. [loop on i] Set i <- 0.
	I4. [Get the remainder] r <- n % b.
	I5. [Save the equivalent char] If r = 10, s[i] <- 'a'. If r = 11,
		s[i] <- 'b', ..,. if r = 15, s[i] <- 'f'.
	I6. [Reduce] Set n <- n/b. 
	I7. [Is n > 0?]. If n > 0, Repeat step I4.
	I8. [is sign negative?] If sign < 0 && b = 10, Set s[i] <- '-'.
	I9. [Add a null character] Set s[i] <- '\0'

*/

#include <stdio.h>
#include <string.h>
#include <limits.h>
#define SIZE 64

void reverse(char s[]);
void itob(int n, char s[], int b);

main()
{
	int n, b;
	char s[SIZE];

	n = -15;
	b = 2;
	do {
		itob(n, s, b);
		printf("%d in base %2d is: %s\n", n, b, s);
	} while (b++, b <= 16);

	return 0;
}
void reverse(char s[])
{
	int c, i, j;

	for (i = 0, j = strlen(s) - 1; i < j; i++, j--) {
		c = s[i];
		s[i] = s[j];
		s[j] = c;
	}
}

void itob(int n, char s[], int b)
{
	int i, sign, r;
	
	if ((sign = n) < 0 && b == 10)
		n = -n;

	i = 0;
	do {
		r = (unsigned) n % b;
		switch(r) {
			case 10: s[i++] = 'a'; break;
			case 11: s[i++] = 'b'; break;
			case 12: s[i++] = 'c'; break;
			case 13: s[i++] = 'd'; break;
			case 14: s[i++] = 'e'; break;
			case 15: s[i++] = 'f'; break;
			default: s[i++] = r + '0'; break;
		}
	} while ((n = (unsigned) n / b) > 0);

	if (sign < 0 && b == 10)
		s[i++] = '-';
	s[i] = '\0';
	reverse(s);
}

